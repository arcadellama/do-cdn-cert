#!/usr/bin/env sh

set -uf
LC_ALL=C

########################################
# Global Variables
########################################

VERBOSE=${VERBOSE:-3}
DIGITALOCEAN_TOKEN="${DIGITALOCEAN_TOKEN:-}"
ACME_DNS="${ACME_DNS:-}"

########################################
# Trap Exit
########################################

trap_exit() {
  cleanup "$tmpdir"
}

# Usage: files for deletion
cleanup() {
  for f in "$@"; do
    if rm -rf "$f"; then
      debug "rm -rf $f"
    else
      die "::cleanup unable to delete $1"
    fi
  done
}

########################################
# STDOUT & STDERR Functions
########################################

usage() {
  cat << EOF 
Usage here.
EOF
}

out() {
  printf %s\\n "$*"
}

die() {
  err "$*"
  exit 1
}

err() {
  >&2 out "$(color r)[$(now)] ERROR: $(color x)$*"
}

warn() {
  if [ "$VERBOSE" -ge 1 ]; then
    out "$(color y)[$(now)] WARN: $(color x)$*"
  fi
}

info() {
  if [ "$VERBOSE" -ge 2 ]; then
    out "$(color g)[$(now)] INFO: $(color x)$*"
  fi
}

debug() {
  if [ "$VERBOSE" -ge 3 ]; then
    out "$(color w)[$(now)] DEBUG: $(color x)$*"
  fi
}

color() {
  _b=$(printf %b '\033[1m') # bold
  case "$1" in
    r) printf %b%b "$_b" '\033[33;31m' ;; # red
    g) printf %b%b "$_b" '\033[33;32m' ;; # green
    y) printf %b%b "$_b" '\033[33;33m' ;; # yellow
    w) printf %b%b "$_b" '\033[33;37m' ;; # white
    x) printf %b%b "$_b" '\033[m' ;;      # reset
    *) warn "color func usage: 'color [r,g,y,x]'" ; return 1 ;;
  esac
}

########################################
# I/O Functions
########################################

make_temp() {
  out "$tmpdir/$(mktemp XXXXXXXXXXXXXXXXX)" || die "::make_tmp fail"
}

path_or_str() {
  # Is it a file path?
  if [ -r "$1" ]; then
    cat "$1"
    debug "::path_or_str is path: $1"
    return
  fi

  # Is it a string?
  if [ -n "$1" ]; then
    out "$1"
    debug "::path_or_str is string: $1"
    return
  fi

  # It's neither (undeclared)
  err "::part_or_string an unset variable?: $1"
  return 1
}

str_to_line() {
  sed 's/$/\\n/' "$@" | tr -d '\n'
}

########################################
# Math & Time Functions
########################################

days_left() {
  minuend=$(date_to_days "$1")
  subtrahend=$(date_to_days "$2")
  printf %d\\n $(( minuend - subtrahend ))
}

now() {
  TZ="UTC" date +'%Y-%m-%dT%H:%M:%SZ'
}

date_to_secs() {
  # GNU date
  if date -d "$1" '+%s' 2>/dev/null; then
    info "Using GNU date."
    return
  fi
  
  # BSD date
  if date -j -f '%Y-%m-%dT%H:%M:%SZ' "$1" '+%s' 2>/dev/null; then
    info "Using BSD date."
    return 
  fi

  err "::date_to_seconds: Unable to convert time."
  return 1
}

date_to_days() {
  datesecs=$(date_to_secs "$1")
  onedaysecs=32400
  printf %d\\n $(( datesecs / onedaysecs ))
}

is_int() {
  printf %d "$1" 2>/dev/null
}

########################################
# curl Functions
########################################

build_header() {
  for h in "$@"; do
    printf '%s "%s" ' "-H" "$h"
  done
}

build_data() {
  for d in "$@"; do
    if [ -r "$d" ]; then
      printf '%s "@%s" ' "-d" "$d"
    else
      printf '%s "%s" ' "-d" "$d"
    fi
  done
}

_curl() {
  method="$1"
  endpoint="$2"
  headers="$3"
  data="$4"
  response="$(make_temp)"
  payload="$endpoint"
  fn_use="_curl <GET|PUT|POST|DELETE> <endpoint> <headers> <data>"
  ret=""

  debug "_curl::method=$method"
  debug "_curl::endpoint=$endpoint"
  debug "_curl::headers=$headers"
  debug "_curl::data=$data"
  debug "_curl::response=$response"

  # Check for bare-minimum defaults
  case "$method" in
    GET|PUT|POST|DELETE) : ;;
    *) err "$fn_use" ; die "Invalid HTTP method: $method" ;;
  esac

  test -n "$endpoint" || die "_curl: must declare an endpoint, $fn_use"

  if [ -n "$data" ]; then
    payload="${data} ${payload}"
  fi

  if [ -n "$headers" ]; then
    payload="${headers} ${payload}"
  fi

  debug "_curl::payload=$payload"

  if ! ret="$("$CURL_BIN" -s \
      -o "$response" \
      -w '%{http_code}' \
      -X "$method" \
      "$payload")"; then
      die "Function curl_get fatal error: $ret"
  fi

  debug "curl_get::ret=$ret"

  if [ "$ret" -ne 200 ]; then
    # Return the error code
    printf %s\\n "$ret"
    return 1
  fi

  # Return the path to the json response
  printf %s\\n "$response"

}

########################################
# Program Variables
########################################

#do_api="https://api.digitalocean.com/v2"
#do_cdn_endpoint="$do_api/cdn/endpoints"
#do_cert_endpoint="$do_api/certificates"
#do_api_content_type="application/json"
tmpdir="$(mktemp -d)" || die "Unable to mktemp -d: $?"

########################################
# Program Functions
########################################

list() {
_usage="list [cdn|certs] [<id>|all]"
  case "$1" in
    cdn) list_cdn "$2" ;;
    certs) list_certs "$2" ;;
    *) die "$_usage" ;;
  esac
}

create() {
_usage="create cert <name> <private_key> <leaf_cert> <cert_chain>"
  case "$1" in
    cert) shift ; create_cert "$@" ;;
    *) die "$_usage" ;;
  esac
}

renew() {
_usage="renew [<cdn_id>|all]"
  case "$1" in
    all) renew_all ;;
    *) renew_cdn "$1" ;;
  esac
}

main() {
  arg_cmd=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      # Commands
      renew|list|create)
        [ -n "$arg_cmd" ] || die "$(usage)"
        arg_cmd="$1 $2"
        debug "arg_cmd=$arg_cmd"
        shift 2 ;;
      # Flags
      --dns)
        ACME_DNS="$2" 
        shift 2 ;;
      --do-token)
        if ! do_token=$(path_or_str "$2"); then
          die "Usage: '--do-token' <string|path>"
        fi
        debug "do_token=$do_token"
        shift 2
        ;;
      # Logging / Usage
      -v) VERBOSE=1 ; shift ;;
      -vv) VERBOSE=2 ; shift ;;
      -vvv|--debug) VERBOSE=3 ; shift ;;
      --verbose)
        if ! VERBOSE=$(is_int "$2"); then 
          die "Usage: '--verbose=<int>'"
        fi
        shift 2 ;;
      -q|--quiet) VERBOSE=-1 ; shift ;;
      -h|--help|usage) usage ; return ;;
      *) die "$(usage)" ;;
    esac
  done

  "$arg_cmd"
}
trap trap_exit EXIT
# main "$@"
make_temp
